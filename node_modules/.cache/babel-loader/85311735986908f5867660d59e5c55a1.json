{"remainingRequest":"C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\vue-keyboard\\src\\keyboard.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\vue-keyboard\\src\\keyboard.vue","mtime":1496393776000},{"path":"C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\claudia.ligidakis\\Desktop\\for-claudia\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.number.constructor\";\nvar Tokens = {\n  // Sequences that no-one will ever put in their keyboards.\n  PIPE: '7440011c983cf39ae730b1f831e2922ac5a76910',\n  OPEN_BRACE: 'f630c4abcae620278f82e142a526ef325c2a773a',\n  CLOSE_BRACE: 'ad982c66898e02a5dab419ea7568421b03f68ee2'\n};\nexport default {\n  name: 'keyboard',\n  props: {\n    value: {\n      type: String,\n      default: ''\n    },\n    layouts: {\n      type: [String, Array],\n      required: true\n    },\n    maxlength: {\n      type: Number,\n      default: 0,\n      validator: function validator(value) {\n        return value >= 0;\n      }\n    },\n    pattern: {\n      type: String,\n      default: null\n    }\n  },\n  data: function data() {\n    return {\n      layout: 0\n    };\n  },\n  computed: {\n    /**\n     * Whether or not the keyboard input has hit its maximum length.\n     * @returns {Boolean}\n     */\n    full: function full() {\n      return this.maxlength > 0 && this.value.length >= this.maxlength;\n    },\n\n    /**\n     * Whether or not the keyboard input is empty.\n     * @return {Boolean}\n     */\n    empty: function empty() {\n      return this.value.length === 0;\n    },\n\n    /**\n     * Returns the lines that make up a layout.\n     * @return {Array}\n     */\n    lines: function lines() {\n      var layout = (Array.isArray(this.layouts) ? this.layouts : [this.layouts])[this.layout];\n      return layout.replace('||', Tokens.PIPE).replace('{{', Tokens.OPEN_BRACE).replace('}}', Tokens.CLOSE_BRACE).split('|');\n    },\n\n    /**\n     * Returns an array of buttons to render in the component.\n     * @returns {Array[]}\n     */\n    buttons: function buttons() {\n      var _this = this;\n\n      return this.lines.map(function (line) {\n        // TODO: Could potentially rely on Object.values() here instead of being explicit.\n        var stream = line.match(new RegExp(\"(\".concat(Tokens.OPEN_BRACE, \"|\").concat(Tokens.CLOSE_BRACE, \"|\").concat(Tokens.PIPE, \"|.)\"), 'g'));\n        var buttons = [];\n        var token = null;\n        stream.forEach(function (char) {\n          if (char === '{') {\n            token = '';\n          } else if (char === '}') {\n            var command = token.split(':');\n            var text = command.length > 1 ? command[0] : '';\n            var action = command.length > 1 ? command[1] : command[0];\n            var args = command.length > 2 ? command[2] : null;\n            var method = null;\n            if (['append', 'backspace', 'space', 'clear', 'goto'].indexOf(action) >= 0) method = _this[action].bind(_this, args);else method = _this.$emit.bind(_this, action, _this);\n            buttons.push({\n              type: 'action',\n              action: {\n                name: action.replace(/\\s+/g, '-').toLowerCase(),\n                callable: method\n              },\n              value: text,\n              args: args\n            });\n            token = null;\n          } else {\n            if (token !== null) {\n              token += char;\n            } else {\n              if (char === Tokens.PIPE) char = '|';\n              if (char === Tokens.OPEN_BRACE) char = '{';\n              if (char === Tokens.CLOSE_BRACE) char = '}';\n              buttons.push({\n                type: 'char',\n                action: {\n                  name: null,\n                  callable: _this.append.bind(_this, char)\n                },\n                value: char,\n                args: null\n              });\n            }\n          }\n        });\n        return buttons;\n      });\n    },\n\n    /**\n     * Whether or not the current value matches the regex provided to pattern. Always\n     * returns true if no pattern was provided.\n     * @returns {Boolean}\n     */\n    valid: function valid() {\n      return !this.pattern || this.value.match(new RegExp(this.pattern));\n    }\n  },\n  methods: {\n    /**\n     * Mutates the keyboard value to a new value.\n     * @param {String} value The new value.\n     */\n    mutate: function mutate(value) {\n      if (this.maxlength > 0) {\n        value = value.slice(0, this.maxlength);\n      }\n\n      this.$emit('input', value);\n    },\n\n    /**\n     * Appends a new value to the end of the current keyboard value.\n     * @param {String} char The character(s) to append.\n     */\n    append: function append(char) {\n      this.mutate(this.value + char);\n    },\n\n    /**\n     * Remove the last character from the current keyboard value.\n     */\n    backspace: function backspace() {\n      this.mutate(this.value.slice(0, this.value.length - 1));\n    },\n\n    /**\n     * Add one whitespace character to the current keyboard value.\n     */\n    space: function space() {\n      this.append(' ');\n    },\n\n    /**\n     * Go to a new layout.\n     * @param {Number} The layout index.\n     */\n    goto: function goto(layout) {\n      if (Array.isArray(this.layouts)) {\n        if (layout >= 0 && layout < this.layouts.length) {\n          this.layout = layout;\n        } else {\n          throw new Error('The requested layout does not exist.');\n        }\n      } else {\n        throw new Error('A single non-array layout was provided.');\n      }\n    },\n\n    /**\n     * Clear the entire keyboard value.\n     */\n    clear: function clear() {\n      this.mutate('');\n    }\n  }\n};",{"version":3,"sources":["keyboard.vue"],"names":[],"mappings":"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","sourcesContent":["<script>\r\n\tconst Tokens = {\r\n\t\t// Sequences that no-one will ever put in their keyboards.\r\n\t\tPIPE: '7440011c983cf39ae730b1f831e2922ac5a76910',\r\n\t\tOPEN_BRACE: 'f630c4abcae620278f82e142a526ef325c2a773a',\r\n\t\tCLOSE_BRACE: 'ad982c66898e02a5dab419ea7568421b03f68ee2'\r\n\t};\r\n\r\n\texport default {\r\n\t\tname: 'keyboard',\r\n\t\t\r\n\t\tprops: {\r\n\t\t\tvalue: {\r\n\t\t\t\ttype: String,\r\n\t\t\t\tdefault: ''\r\n\t\t\t},\r\n\t\t\tlayouts: {\r\n\t\t\t\ttype: [String, Array],\r\n\t\t\t\trequired: true\r\n\t\t\t},\r\n\t\t\tmaxlength: {\r\n\t\t\t\ttype: Number,\r\n\t\t\t\tdefault: 0,\r\n\t\t\t\tvalidator: value => value >= 0\r\n\t\t\t},\r\n\t\t\tpattern: {\r\n\t\t\t\ttype: String,\r\n\t\t\t\tdefault: null\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdata() {\r\n\t\t\treturn {\r\n\t\t\t\tlayout: 0\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tcomputed: {\r\n\t\t\t/**\r\n\t\t\t * Whether or not the keyboard input has hit its maximum length.\r\n\t\t\t * @returns {Boolean}\r\n\t\t\t */\r\n\t\t\tfull() {\r\n\t\t\t\treturn this.maxlength > 0 && this.value.length >= this.maxlength;\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Whether or not the keyboard input is empty.\r\n\t\t\t * @return {Boolean}\r\n\t\t\t */\r\n\t\t\tempty() {\r\n\t\t\t\treturn this.value.length === 0;\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns the lines that make up a layout.\r\n\t\t\t * @return {Array}\r\n\t\t\t */\r\n\t\t\tlines() {\r\n\t\t\t\tlet layout = (Array.isArray(this.layouts) ? this.layouts : [this.layouts])[this.layout];\r\n\r\n\t\t\t\treturn layout.replace('||', Tokens.PIPE)\r\n\t\t\t\t\t.replace('{{', Tokens.OPEN_BRACE)\r\n\t\t\t\t\t.replace('}}', Tokens.CLOSE_BRACE)\r\n\t\t\t\t\t.split('|');\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Returns an array of buttons to render in the component.\r\n\t\t\t * @returns {Array[]}\r\n\t\t\t */\r\n\t\t\tbuttons() {\r\n\t\t\t\treturn this.lines.map(line => {\r\n\t\t\t\t\t// TODO: Could potentially rely on Object.values() here instead of being explicit.\r\n\t\t\t\t\tlet stream = line.match(new RegExp(`(${Tokens.OPEN_BRACE}|${Tokens.CLOSE_BRACE}|${Tokens.PIPE}|.)`, 'g'));\r\n\r\n\t\t\t\t\tlet buttons = [];\r\n\t\t\t\t\tlet token = null;\r\n\r\n\t\t\t\t\tstream.forEach(char => {\r\n\t\t\t\t\t\tif (char === '{') {\r\n\t\t\t\t\t\t\ttoken = '';\r\n\t\t\t\t\t\t} else if (char === '}') {\r\n\t\t\t\t\t\t\tlet command = token.split(':');\r\n\t\t\t\t\t\t\tlet text = command.length > 1 ? command[0] : '';\r\n\t\t\t\t\t\t\tlet action = command.length > 1 ? command[1] : command[0];\r\n\t\t\t\t\t\t\tlet args = command.length > 2 ? command[2] : null;\r\n\t\t\t\t\t\t\tlet method = null;\r\n\r\n\t\t\t\t\t\t\tif (['append', 'backspace', 'space', 'clear', 'goto'].indexOf(action) >= 0) method = this[action].bind(this, args);\r\n\t\t\t\t\t\t\telse method = this.$emit.bind(this, action, this);\r\n\r\n\t\t\t\t\t\t\tbuttons.push({\r\n\t\t\t\t\t\t\t\ttype: 'action',\r\n\t\t\t\t\t\t\t\taction: { name: action.replace(/\\s+/g, '-').toLowerCase(), callable: method },\r\n\t\t\t\t\t\t\t\tvalue: text,\r\n\t\t\t\t\t\t\t\targs\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\ttoken = null;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (token !== null) {\r\n\t\t\t\t\t\t\t\ttoken += char;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (char === Tokens.PIPE) char = '|';\r\n\t\t\t\t\t\t\t\tif (char === Tokens.OPEN_BRACE) char = '{';\r\n\t\t\t\t\t\t\t\tif (char === Tokens.CLOSE_BRACE) char = '}';\r\n\r\n\t\t\t\t\t\t\t\tbuttons.push({\r\n\t\t\t\t\t\t\t\t\ttype: 'char',\r\n\t\t\t\t\t\t\t\t\taction: { name: null, callable: this.append.bind(this, char) },\r\n\t\t\t\t\t\t\t\t\tvalue: char,\r\n\t\t\t\t\t\t\t\t\targs: null\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn buttons;\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Whether or not the current value matches the regex provided to pattern. Always\r\n\t\t\t * returns true if no pattern was provided.\r\n\t\t\t * @returns {Boolean}\r\n\t\t\t */\r\n\t\t\tvalid() {\r\n\t\t\t\treturn !this.pattern || this.value.match(new RegExp(this.pattern));\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tmethods: {\r\n\t\t\t/**\r\n\t\t\t * Mutates the keyboard value to a new value.\r\n\t\t\t * @param {String} value The new value.\r\n\t\t\t */\r\n\t\t\tmutate(value) {\r\n\t\t\t\tif (this.maxlength > 0) {\r\n\t\t\t\t\tvalue = value.slice(0, this.maxlength);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.$emit('input', value);\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Appends a new value to the end of the current keyboard value.\r\n\t\t\t * @param {String} char The character(s) to append.\r\n\t\t\t */\r\n\t\t\tappend(char) {\r\n\t\t\t\tthis.mutate(this.value + char);\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Remove the last character from the current keyboard value.\r\n\t\t\t */\r\n\t\t\tbackspace() {\r\n\t\t\t\tthis.mutate(this.value.slice(0, this.value.length - 1));\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Add one whitespace character to the current keyboard value.\r\n\t\t\t */\r\n\t\t\tspace() {\r\n\t\t\t\tthis.append(' ');\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Go to a new layout.\r\n\t\t\t * @param {Number} The layout index.\r\n\t\t\t */\r\n\t\t\tgoto(layout) {\r\n\t\t\t\tif (Array.isArray(this.layouts)) {\r\n\t\t\t\t\tif (layout >= 0 && layout < this.layouts.length) {\r\n\t\t\t\t\t\tthis.layout = layout;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('The requested layout does not exist.');\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('A single non-array layout was provided.');\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t/**\r\n\t\t\t * Clear the entire keyboard value.\r\n\t\t\t */\r\n\t\t\tclear() {\r\n\t\t\t\tthis.mutate('');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n</script>\r\n\r\n<template>\r\n\t<aside class=\"vue-keyboard\" role=\"application\" :class=\"{ full: full, empty: empty, valid: valid, invalid: !valid }\" :data-value=\"value\" :data-layout=\"layout\">\r\n\t\t<div role=\"row\" class=\"vue-keyboard-row\" v-for=\"row in buttons\" :data-keys=\"row.length\">\r\n\t\t\t<button\r\n\t\t\t\tv-for=\"btn in row\"\r\n\t\t\t\tclass=\"vue-keyboard-key\"\r\n\t\t\t\trole=\"button\"\r\n\t\t\t\t:class=\"btn.type\"\r\n\t\t\t\t:data-args=\"btn.args\"\r\n\t\t\t\t:data-text=\"btn.value\"\r\n\t\t\t\t:data-action=\"btn.action.name\"\r\n\t\t\t\t@click.prevent=\"btn.action.callable\"\r\n\t\t\t>{{ btn.value }}</button>\r\n\t\t</div>\r\n\t</aside>\r\n</template>\r\n\r\n<style>\r\n\t.vue-keyboard-row {\r\n\t\tpadding: 2px 0;\r\n\t\ttext-align: center;\r\n\t}\r\n\r\n\t.vue-keyboard-key {\r\n\t\tborder: none;\r\n\t\toutline: none;\r\n\t\tpadding: 8px 10px;\r\n\t\tmin-width: 40px;\r\n\t\tmargin: 0 2px;\r\n\t\tbackground: #EEE;\r\n\t\tcolor: #666;\r\n\t\tcursor: pointer;\r\n\t\tfont-family: inherit;\r\n\t\tfont-size: inherit;\r\n\t\tborder-radius: 2px;\r\n\t}\r\n\r\n\t.vue-keyboard-key:hover {\r\n\t\tbackground: #E0E0E0;\r\n\t}\r\n\r\n\t.vue-keyboard-key:active {\r\n\t\tbackground: #777;\r\n\t\tcolor: #FFF;\r\n\t\tbox-shadow: inset 0 1px 4px rgba(#000, 0.1);\r\n\t}\r\n\r\n\t.vue-keyboard-key[data-action=\"space\"] {\r\n\t\tmin-width: 160px;\r\n\t}\r\n</style>"],"sourceRoot":"node_modules/vue-keyboard/src"}]}